js是弱类型：类型可变

 alert("");控制浏览器弹出一个警告框

 document.write();可以向body中输出一个内容

 console.log();向控制台输出一个内容。



1,js严格区分大小写

2,js每条语句以分号结尾

3,js会忽视多个空格和换行

 

标识符不能以数字开头

标识符不能是es中的关键字或保留字

标识符一般采用驼峰命名法

 

### Js的六种数据类型:

**String** 字符串  单引号或者双引号都可以 同种引号不能嵌套 \为转义字符 \" 表示 " \\ 表示 \

**Number** 数值 NaN是一个特殊的数字,表示不是一个数字,他的类型是number 若使用JS使用 浮点元素计算,可能得到一个不精确的结果.

**Boolean** 布尔值

**Null** 空值 表示一个为空的对象 类型是Object

**Undefined** 未定义 声明了为赋值的变量

**Object** 对象

**typeof** 检查变量的类型

 

### 强制类型转换:

#### 转换为String

  方法一:调用toString()方法.该方法不会影响原变量,会将转换结果返回.null和undefined没有该方法

  方式二:调用String函数: String() 将被转换数据作为参数传入函数.

#### 转换为Number

方法一 : 调用Number()函数. 如果字符串中有非数字字符,转换为NaN 若字符串为空或者全是空格,转换为0.布尔类型true转为1 false专为0 null转为0 undefined转为 NaN

方法二 :parseInt(a,10) 专门转换字符串.将字符串中的有效整数内容取出转换为number 从前向后寻找到第一个非数字字符. 第二个参数表示进制.

​               parseFloat()作用和parseFloa()类似,不同的是它可以获得有效的小数. 

​               若对非字符型使用上述两个方法,会将其现场转换为String再操作.

​                Js中如果需要表示16进制的数字,则需要以0x开头. 如果需要表示8进制的数字,则需要以0开头.要表示2静止的数字,则需要以0b开头.

#### 转换为boolean:

使用Boolean()函数.数字除了0和NaN都是true 字符串除了空串都是true null和undefined都是false.

#### 运算符:也叫操作符.

typeof就是运算符,返回结果是字符串

**数字运算符**:

**1**,对除字符串的非数字型值相加时,会先将这些值转换为Number类型.任何值和NaN做运 算都得NaN.

**2**,如果对两个字符串做加法运算,会将两个字符串拼接成一个字符串.任何的值和字符串做加法运算,都会先转换为字符串,然后进行拼串. 可以利用这一特点, 任意类型的数据类型值加一个空串都可以将其转换为String.

**3**,任何值做- * / 运算时都会自动转换为Number 我们可以利用这一特点将其-0或*1 /1做隐式的类型转换

**4**,+或者-运算符可以使非数字值转换为数字类型值

 

&& || 非布尔值的情况

​    对于非布尔值进行与或运算时,会将其转换为布尔值,然后运算,并且返回原值

true&&true

与运算:如果两个值都为true,则返回后面的.

flase&&true:返回false  false&&false 如果两个值有false,返回前一个.

总之:与运算第一个值为true,直接返回第二个值,如果第一个值时false,直接返回第一个值.

或运算若第一个值为true,直接返回第一个值,若第一个值为false,直接返回第二个值.

 

非数值进行比较时:会将其转换为数字,再进行比较.任何值和NaN作比较都是false

​        字符串相比较时,比较的是字符的unicode编码,一位一位比较,直到有不同的.

如果比较的是两个字符串型的数字,可能会得到不可预期的效果,所以一定要转型.

 

使用==来比较两个值时,如果值得类型不同,则会自动进行类型转换,将其转换为相同的类型,然后在比较.

undefined衍生自null,这两个值做相等判断时,返回true

NaN不和任何值相等,包括它本身.可以通过isNaN()函数来判断一个值是否是NaN.

==判断两个值是否相等时,会进行类型转换,转换为同等类型来进行比较

=== 全等 判断两个值是否全等,不会进行类型转换

!== 不全等 判断两个值是否不全等,不会进行类型转换

 

运算符优先级:&&高于||

 

prompt()可以弹出一个提示框,提示框中带有一个文本框,用户可以在文本框中输入一段内容,该函数需要一个字符串作为参数,该字符串会作为提示框的提示文字,用户输入的内容会作为函数的返回值返回,可以定义一个变量来接收该内容.

var score = prompt("请输入成绩");

 

 

JS对象的属性名不强制要求i遵守标识符的规范,属性名可以是关键字,

如果要使用特殊的属性名,不能采用.的方式来操作 需要使用另一种方式: 

  语法:对象["属性名"]=属性值

读取时也采用这种方式.

使用[]这种形式去操作属性,更加的灵活,再[]中可以直接传递一个变量,这样变量值是对少就会读取那个属性.

 

JS对象的属性值可以使任意的数据类型,甚至可以是一个对象.

in运算符:通过该运算符可以检查一个对象中是否含有指定的属性.有i返回true 没有返回false

语法:  "属性名" in 对象

 

JS的变量保存在栈内存中:基本数据类型的值直接在栈内存中存储,值与值之间是独立存在的,修改一个比那辆不会影响其他的变量. 

对象保存在堆内存中,每创建一个新的对象,就在堆内存中开辟一个新的空间.变量保存的是对象的内存引用,如果两个变量保存的是同一个对象引用,当通过一个变量修改属性时,另一个也会受到影响.

比较两个基本数据类型的值时,就是比较值,量比较两个引用数据类型时,他比较的是对象的内存地址

 

使用对象字面量来创建对象:

​    var obj = {属性名:属性值,属性名:属性值 };

对象字面量的属性名可以加引号,也可以不加,建议不加,如果使用一些特殊的名字,必须加引号.

名和值之间用:连接,多个名值对之间用,隔开.

 

函数:函数也是一个对象.

使用构造函数创建函数对象:

 var fun = new Function("alert(a)"); 可以将要封装的代码以字符串的形式传递给构造函数

使用函数声明来创建一个函数:

语法: 

   function 函数名([形参1,形参2...形参N]){

​    语句

}

使用函数表达式来创建一个函数;

  var 函数名(其实就是变量名) = function([形参1,形参2...形参N]){

   语句....

}

 

实参可以时任意的数据类型,调用函数时解析器不会检查实参的类型,所以又可以能接收到非法的参数,有可能要对参数进行类型检查.

调用函数时没解析器也不会检查实参的数量,多于参数不会被赋值.如果实参的属量少于形参的数量,则没有对应实参的形参将是undefined.

 

在函数中,return后面的语句都不会执行,如果return语句后不跟任何值就相当于返回一个undefined

如果函数中不写return,则也会返回undefined

 

实参可以是任意数据类型,也可以是一个对象,但我们参数过多时,可以将参数封装到一个对象中.将对象传入.实参也可以是一个函数

 

break退出当前循环

continue跳过此次循环

return 结束整个函数

 

返回值可以使任意的数据类型,可以是一个对象,也可以一个函数.

 

直接执行函数:(function(){ }) (形参); 在匿名函数外加一层括号后表示一个整体,然后立即被调用,往往只会执行一次.

 

对象的属性值可以是任意数据类型,也可以是一个函数.当一个函数作为一个是对象的属性保存,称这个函数为i这个对象的方法.

 

枚举对象中的属性 使用 for … in语句

语法: for (var 变量 in 对象){}

for … in 语句 对象中几个对象,循环体执行几次,,.,每次执行时,都会将对象中的一个属性的名字赋值给变量.

obj[]

### 作用域:

#### 1,全局作用域:

   直接编写在script标签中的JS代码,都在全局作用域

   全局作用域在页面打开时创建,在页面关闭时销毁

   在全局作用域中有一个全局对象window,他代表的是一个浏览器的窗口,由浏览器创建,而我们可以直接使用.

   在全局作用域中:创建的变量都会作为window对象的属性保存.

​               创建的函数都会作为window对象的方法保存.

  变量的声明提前:使用var关键字声明的变量,会在所有的代码执行之前被声明(不会赋值).但是如果声明变量不使用var关键字,则变量不会被声明提前.

 函数的声明提前:使用函数声明形式创建的函数 function函数(){} 他会在所有的代码执行前就被创建,可以在函数声明前被调用;

​             使用函数表达式var fun = function(){}创建的函数,不会被提前声明,所以不能在声明前调用.

   全局作用域中的变量都是全局变量.      

#### 2,函数作用域:

调用函数时创建函数作用域,函数执行完毕后,函数作用域销毁

​           每调用一个函数就会创建一个新的函数作用域,他们之间是相互独立的.

​           函数作用域中可以访问到全局作用域中的变量 全局作用域无法访问到函数作用域中的变量.

​           但在函数作用域中操作某个变量时,先在自身作用域中寻找,没有的话就去上一级作用域寻找.直到找到全局作用域,如果全局作用域中依然没有,则会报错ReferenceError.

​           在函数中要访问全局变量可以使用window对象

​           在函数作用域也有声明提前的特性.使用var关键字声明的变量,会在函数中所有的代码执行之前被声明.在函数中,不使用var声明的变量都会成为全局变量

​           函数声明也会在函数中所有的代码执行之前被执行.

​           定义形参就相当于在函数作用域中声明了变量.



### this:

解析器在调用函数每次都会向函数内部传递一个隐含参数this.this指向的是一个对象,这个对象我们称为函数执行的上下文对象,根据函数的调用方式的不同,this会指向不同的对象.

 1,以函数的形式调用时,this就是window

 2,以方法的形式调用时,this就是调用方法的那个对象.

 

构造函数:构造和普通函数的区别就是调用方式的不同

​       普通函数是直接调用,而和构造函数需要使用new关键字来调用.

构造函数执行过程:

 1,立即创建一个对象

  2,将新建对象设置为函数的this

  3,逐行执行函数中的代码

  4,将新建的对象作为返回值返回

 

使用同一个构造函数的对象称为一个类,调用构造i函数的构成称为类的实例化

使用instanceof可以检查一个对象是否是一个类的实例

  对象 instanceof 类

 

将函数定义在全局作用域中,污染了全局作用域的命名空间

 而且定义在全局作用域中也很不安全.

 

原型 prototype

 我们所创建的每一个函数,解析器都会向函数中添加一个属性prototype.这个属性对应着一个对象,这个对象就是原型对象.

如果函数作为普通函数调用,这个属性没有任何作用,当函数通过构造函数调用时,他所创建的对象中,都有一个隐含的属性指向之该构造函数的原型对象.我们可以通过__proto__来访问该属性.

 

原型对象就相当于一个公共区域,所有同一个类的实例都可以访问到这个原型对象,可以将类的公共内容,放在原型对象中.当访问对象的一个属性和方法时,回先在自身中寻找,有则直接使用,若没有,会去原型对象中寻找.

 

以后我i们创建构造函数时,可以将这些对象共有的属性和方法,统一添加到构造函数的原型对象中,这样不用分别为每一个对象添加,也不会影响到全局作用域.就可以使每个对象都具有这些属性和方法了.

 

#### 向原型对象中添加属性或方法:

  类名.prototype.属性名/方法名 = 属性值/方法体 ;

 

使用in检查对象中是否含有某个属性时,如果对象中没有但是原型中有,也会返回ture.

使用对象的hasOwnOroperty()来检查对象自身中是否含有该属性时,果对象中没有但是原型中有,会返回false.

原型对象也有原型对象,直到找到Object对象的原型,Object对象的原型没有原型.若还没找到返回null.

 

当我们直接在页面中打印一个对象时,实际上是输出的对象的toString()方法的返回值.如果我们希望和再输出对象时不输出object 可以为对象添加一个toString()方法.修改类的原型的toString()方法,可以修改所有对象的方法.

 

### 內建对象:

#### 数组:

**push()**方法:向数组末尾添加元素,返回的是新数组的长度.

pop()方法:删除数组最后一个元素,返回的是删除的元素.

**unshift()**方法:向数组就开头添加一个或者多个元素,并返回新的数组长度.

**shift()**方法:删除数组第一个元素,返回删除的元素.

 数组遍历:**forEach()**方法:

   数组的forEach()方法需要一个函数作为参数,

   想着一种函数,有我们创建但不有我们调用的,我们称为回调函数

   数组中有几个元素函数就会执行几次,每次执行时,浏览器会将遍历到的元素以实参的形式传递进来,可以定义形参来读取内容

 浏览器会在回调函数中传递三个参数:

   第一个参数,就是当前正在遍历的元素.

   第二个参数,是当前元素的索引值

   第三个参数,是正在遍历的数组.

**slice(start,end)**方法:可以从数组中提取指定元素.参数:截取开始位置索引,截取结束位置索引.前闭后开.第二个参数可以可以省略,省略时默认到数组末尾. 索引可以传递负值,表示从后往前数.

该方法不会改变原数组,将结果封装到新数组返回.

**splice(start,end)**方法:删除数组中的指定元素,会改变原数组,并将删除的元素作为新的数组返回.第一个参数为开始位置索引,第二个参数为要删除的元素数量.第三个及以后的参数,可以传递一些新的元素,这些元素就按会自动插入到开始位置索引前面.

**concat()**方法:可以连接两个或者多个数组,并将新的数组返回.该方法不会对原数组产生影响.参数也可以是多个元素.

**join(连接符)**方法:该方法可以将一个数组转换为字符串.也不会原数组产生影响.再方法中可以指定一个字符串作为参数,这个字符串会成为数组中元素的连接符.如果不指定,默认逗号.

**reverse()**方法:该方法用来反转数组顺序,对原数组直接修改.

**sort()**方法:对元素的元素进行排序,对原数组直接修改.排序使用的时unicode编码进行排序,即使是纯数字数组也是,所以可能得到错误结果.

可以再sort()中添加一个回调函数,来指定排序规则,回调函数中需要定义两个形参,浏览器将分别使用数组中的元素作为实参去调用回调函数.sort(function(a,b){}) 使用数组的那个元素不确定,但是肯定的是再数组中a一定在b前面. 浏览器会根据回调函数的返回值来决定元素的顺序,如果返回一个大于0的值,则元素会交换位置.返回小于零的值,位置保持不变.返回0,则认为两个元素相等,位置不变.所以回调函数在需要升序时,返回a-b 需要降序时,返回b-a.

#### 函数的方法:

call()方法和apply()方法.需要通过函数对象来调用,

当对函数调用call()和apply()方法都会调用函数执行.

在调用call()方法和apply()方法可以将一个对象指定为第一个参数.此时这个对象将成为函数执行时的this.

call()方法可以将实参在对象之后依次传递

apply()方法需要将实参等转到数组中统一传递

#### this的情况:

1,以函数形式调用时,this永远都是window

2,以方法的形式调用时,this永远都是调用方法的对象

3,以构造函数的形式调用时,this时新创建的那个对象

4,使用call和apply调用时,this是指定的那个对象

 

在调用函数时,浏览器每次都会传递进两个隐含的参数;

1,函数的上下文对象

2,封装实参的对象arrguments

  arrguments是一个类数组对象,可以通过索引操作,获取长度

  在调用函数时,我们传递的实参都会在arrguments中保存

  arrguments.length就是实参的数量.

  即使不定义形参,也可以用arrguments来使用实参.

arrguments.claaee属性对应一个函数对象,就是当前正在指向的函数的对象.

 

#### 日期对象:表示时间

var d = new Date(); 如果使用构造函数来创建一个Date对象,则会封装为当前代码执行时间,

创建一个指定的时间对象:需要在构造函数中传递一个表示时间的字符串作为参数.格式:月/日/年 时:分:秒

 

时间对象方法:

**getDate()**方法:获取当前日期对象是几日 (1-31)

**getDay()**方法:获取当前日期对象是周几 (0-6) 0是周日

**getmonth():**获取当前日期对象的月份(0-11) 0是一月

**getfullyear():**获取当前日期对象的完整年份

以此类推.

**getTime();**获取当前日期对象的时间戳,从格林威治标准时间1970年1月1日0时0分0秒开始到当前日期所花费的毫秒数.

获取当前时间戳:time = Date.now(); 

#### Math:

和其他对象不同,他不是一个构造函数,它属于一个工具类不用创建对象,它里面封装了数学运算相关的属性和方法. 

方法:

**ceil()**;对小数进行向上取整.

**floor()**:对小数进行向下取整

**round()**:对数进行四舍五入

**random()**:生成一个0-1之间的随机数

生成0-x之间的随机数只需乘以x即可,可以取整

生成x-y之间的随机数乘以(y-x)后整体加上x即可.

**max()**;获取多个数中的最大值.

**min()**最小值

**pow(x,y)**返回x的y次幂

**sqart()**;返回一个数的平方根

其他方法查找文档.

#### 包装类:将基本数据类型转换为对象

String() 将基本数据类型字符串转换为String对象

Number() 将基本数据类型数字转换为Number对象

Boolean() 将基本数据类型的布尔值转换为Bolean对象

实际应用中,基本不会使用基本数据类型的对象.

方法和属性只能添加给对象,不能添加给基本数据类型

当我们对一些基本数据类型的值去调用属性和方法时,浏览器会临时使用包装类将其转换为对象,然后再调用对象的属性和方法.调用完之后,再将其转换为基本数据类型.

#### String对象的方法:

在底层字符串是以字符数组的形式保存的.

**charAt()**:返回字符串中指定位置的字符.

**charCodeAt()**返回字符串中指定位置字符的字符编码.

**String.fromcharCode()**:根据字符编码获取一个字符. 用构造函数去调用.

**concat()**:连接两个或者多个字符串,作用和+一样.

**indexof()**:检索字符串是否含有指定内容.返回的是第一次出现的索引值.若没找到,返回-1 第二个参数也可以指定开始查找位置

**lastIndexOf()**;从后向前检索.

**slice(start,end)**:从字符串中截取指定的内容,返回新的字符串,左闭右开

省略第二个参数,则一直到结尾,传递负数时,从后向前计算.

**substring();**也可以用来截取一个字符串,和slice()类似.不同的是,这个方法不能接受负值作为参数,当作0处理.如果第二个参数小于第一个参数,会自动调整参数位置.

**substr:**用来截取字符串,第一个参数是开始位置索引,第二个参数位截取的长度.

**split():**可以将一个字符串拆分为一个数组.参数为一个字符串,会根据该字符串去拆分数组.若传递一个空串,则会将每个字符都拆分为数组中的一个元素.

**parseInt()**:将一个字符串中的合法数字取出来

 正则表达式:用于定义一些字符串的规则.

计算机可以根据正则表达式,来检查一个字符串是否符合规则.

获取将字符串中符合规则的内容提取出来.

1,创建正则表达式的对象:

语法:  var 变量 = new RegExp("正则表达式","匹配模式");

2,使用字面量来创建正则表达式:

  语法: var 变量 = /正则表达式/匹配模式

匹配模式: i 忽略大小写

​        g 全局匹配模式

正则表达式的方法:

test();检查一个字符串是否符合正则表达式的规则.

 

### 正则表达式:

"a" 检查字符串中是否含有a

"a|b"检查字符串中是否含有a或者b

"[A-z]"检查字符串中是否有任意字母 []里的内容也是或的关系.

[^]表示检查字符串中是否有除了[]里的内容的字符串

#### 字符串和正则表达式相关的方法:

**search():**检索字符串中是否有指定内容,参数可以是正则表达式.搜索到返回第一次出现索引,搜索不到返回-1.此方法不可全局匹配.

**match()**:根据正则表达式,从一个字符串中将符合条件的内容提取出来.默认情况下,找到第一个符合要求内容,就会停止检索,可以设置正则表达式为全局匹配模式,这样就会匹配到所有内容.可以为一个正则表达式设置多个匹配模式,且顺序无所谓.会将匹配到的内容封装到数组中返回.

**split();**将一个字符串按参数为分隔符拆分成数组,参数里可以用正则表达式.此方法即使没有指定全局匹配,也都会全部拆分.

**replace()**;将字符串中指定内容替换为新的内容.

  参数:1,被替换的内容  可以接受一个正则表达式作为参数

​           2,新的内容

默认只会替换第一个,匹配模式更换为全局模式

#### 正则表达式语法:

量词:通过量词可以设置一个内容出现的次数,量词只对前面一个元素起作用,若多个元素,用括号括起来.

/a{3}/ a连续出现3次

/(ab){3}/ ab连续出现三次

/a{1,3}/ a连续出现1-3次

/a+/ a至少出现一次

/a*/ a出现0次或多次

/a?/a出现0次或1个

/^a/以a开头

/a$/以a结尾

若再正则表达式中同时使用^和$则要求字符串必须完全符合正则表达式.

如/^a$/ 必须是"a"

#####  在正则表达式中使用\作为转义字符.

/./任意字符

/\./检查是否有.

/\\/检查是否有\

注意:在构造函数中,由于他的参数是一个字符串,而\是字符串中的转义字符,如果要使用\则需要使用\\来代替.

##### 元字符:预定义类

\w :表示任意字母,数字和下划线

\W : 除了字母,数字,下划线.

\d : 任意的数字 [0-9] 

\D 除了数字 [^0-9]

\s 空格

\S 除了空格

\b 单词边界

\B 除了单词边界

 

## 宿主对象:

### DOM对象: Document Object Model 文档对象模型

文档:整个html网页文档

对象:对象表示将网页中的每一个部分都转换为了一个对象

模型:使用模型来表示对象之间的关系,这样方便我们获取对象

节点:构成网页最基本的组成部分,网页中的每一个部分都是一个节点.

   常用节点分为四类:文档节点:整个html文档

​                 元素节点:html文档中的html标签

​                 属性节点:元素的属性

​                 文本节点:html标签中的文本内容

#### 事件:

为按钮的对应事件绑定处理函数的形式来响应事件.

var btn = document.getElementById("btn");

btn.onclick = functiom(){};

 

#### DOM方法:

获取元素节点:通过document对象调用

**getElementById()**: 通过id属性获取一个元素节点对象

**getEiementsByTagName()**:通过标签名获取一组元素节点对象

**getElementsByName()**: 通过name属性获取一组元素节点对象

 如果需要读取元素内的属性:直接使用元素.属性

​        当时class属性不能采用这种方法,读取calss属性时需要使用

​       元素.className

##### 获取元素节点的子节点: 通过元素节点对象调用

**getElementsByTagName():**方法 ,返回当前节点的指定标签名后代节点

**childNodes** 属性 表示当前系欸但的所有子节点 会获取包括文本节点在内的所有节点. DOM标签之间的空白也会被当成文本节点

**children** 属性 可以获取当前元素的所有子元素

**firstChild** 属性 表示当前节点的第一个子节点 包括空白文本节点

**firstElementChild** 属性获取当前元素的第一个子元素

**lastChild** 属性 表示当前节点的最后一个子节点

**lastElementChild** 属性获取当前元素的最后一个子元素

 

#### 获取父节点和兄弟节点:通过具体的节点调用

**parentNode** 属性 表示当前节点的父节点

**previousSibling** 属性 表示当前节点的前一个兄弟节点

**nextSibling** 属性 表示当前节点的后一个兄弟节点

#### 定义一个函数,专门来为指定元素绑定单击响应事件

参数:   idStr 要绑定单击响应函数的对象的id属性值

​      fun 事件的回调函数

function myClick(idStr fun){

  var btn = document.getElementById(idStr);

   btn.onclick = fun;

}

#### DOM查询的其他方法:

document.body 获取body标签

document.documentElement 获取html标签

document.all 获取页面中所有的元素 相当于       document.getElementsByTagName(*)

document.getElementsByClasssName() 根据元素的class属性值获取一组元素节点对象

document.querySelector(".box1 div") 需要一个选择器的字符串作为参数,可以根据一个css原则其来查询一个元素节点对象.该方法只会返回符合要求的第一个元素.

document.querySelectorAll(); 这个方法会返回符合要求的所有元素.即使符合条件的元素只有一个,也是会返回一个数组.

 

#### DOM的增删改:

appendChild() :将新的子节点添加到指定节点 子节点作为参数传入,由父节点调用.

removeChild() :删除子节点 参数为被删除子节点 调用者为父节点.

replaceChild() :替换子节点 第一个参数为新节点,第二个人参数为旧节点

insertBefore() : 再指定的子节点之前插入新的子节点,第一个参数为插入的新节点,第二个参数为指定的子节点,方法由父节点调用.

createAttribute() : 创建属性节点.

createElement()可以用来创建一个元素节点对象,他需要一个标签名做为参数,根据标签名来创建元素节点对象,并将该对象返回.

createTextNode()创建一个文本节点,需要一个文本内容作为参数,并将新的节点返回.

 

**使用innerHtml也可以完成DOM的增删改的相关操作**.

**使用DOM操作内联样式: 通过style设置和读取的都是内联样式,不是样式表中的.*****

 

 元素.style.样式名 = "样式值"  通过这种方法设置的是内联样式,优先级较高,

若css样式名中含有- 是不合法的阿,需要将这种样式名修改为驼峰命名法,去掉-,然后-后的字母大写.

如果再样式中写了! important 则此时样式会有最高的优先级.

读取内联样式: 元素.style.样式名

##### 使用DOM操作样式表样式:

元素.currentStyle.样式名:  获取当前元素正在显示的样式,如果当前元素没有设置该样式,则返回默认值. 只有ie支持.

其他浏览器中需要使用:getComputedStyle()方法 该方法时window自带,直接使用不需要调用者.第一个参数为要获取样式的元素,第二个参数可以传递一个为元素,一般都传null.该方法会返回一个对象,对象中封装了当前元素对应的样式.通过对象.样式名来读取样式,如果获取的样式没有设置,则会获取到真实的值,而不是默认值.该方法不支持ie8及以下

通过currentStyle和getComputedStyle()方法读取到的样式都是只读的,不能修改,如果要修改必须通过style属性.

##### 其他样式操作的属性:

element.clientWidth :返回元素的可见高度

element.clientHeight :返回元素的可见宽度 这两个属性都是不带px的,返回都是数字,可以直接进行计算. 获取元素宽度和高度,包括内容区和内边距. 这些属性也是只读的.

element.offsetWidth

element.offsetHeight  获取元素的整个的宽度和高度,包括内容区,内边距和边框element.offsetParent 获取当前元素的定位父元素

element.offsetLeft

element.offsetTop 当前元素相对于其定位父元素的偏移量

element.scollWeigh

element.scollHeight 获取元素整个滚动区的宽度和高度

element.scollLeft

element.scollTop 获取元素滚动条滚动的距离

当满足scollHeight - scollTop ==clientHeight时,表示滚动条到底了.

onmousemove: 事件会在鼠标再元素中移动时被触发.

#### 事件对象:

在事件对象中封装了当前事件的一切信息,比如,鼠标的坐标,键盘那个按键被按下,鼠标滚轮滚动方向等

当事件的响应函数被触发时,浏览器每次都会将一个事件对象作为实参传递进响应函数.但是在ie8及以下的浏览器中并不会传递事件对象,事件事件对象作为window对象的属性保存的.需要使用window.event.属性

为保证兼容性,提前进行处理 event = event || window.event;

事件对象属性: 调用方法 event.属性

clientX:可以获取鼠标指针在可见窗口的水平座标

clientY:可以获取鼠标指针在可见窗口的垂直坐标.

pageX:

pageY: 获取鼠标指针在整个页面的水平坐标和垂直坐标. ie8中不支持此属性.

如果有滚动条时,

#### 事件的冒泡(Bubble):

指事件的向上传导,但后代元素上的事件被触发时,其祖先元素的相同事件也会被触发.在开发中大部分情况冒泡都是有用的.

如果不想冒泡事件出现,可以通过事件对象来取消冒泡: 

event.cancelBubble = true;

####  事件的委派:

事件的向下传导,将事件听译绑定给元素的共同的祖先元素,这样当后代元素上的事件触发时,会一直冒泡到祖先元素,从而通过祖先元素的响应函数来处理事件.事件委派是利用了冒泡,通过委派可以减少事件绑定的次数,提高程序的性能

但是为了保证其他兄弟元素不触发事件,需要过滤选择执行的元素.

event.target:表示触发事件的对象 event.target.className==?

#### 事件的绑定:

addEventLinsener() : 通过这个方法也可以为一个元素的相同事件绑定多个响应函数,事件被触发时,函数按照绑定顺序执行

​    参数: 1, 事件的字符串,不要on

​        2,回调函数

​         3,是否在捕获阶段触发事件,一般为false

ie8中使用attachEvent()来绑定事件: 这个方法也可以为一个事件绑定多个响应函数,执行顺序与addEventListener()相反,后绑定,先执行.

​     参数:1.事件的字符串 要 on

​         2,回调函数

addEventListener() 中的this,是绑定事件的对象

attachEvent()中的this,是window

 

定义一个函数,用来为指定元素绑定响应函数,考虑兼容性

function bind(obj ,eventStr , callback){

​      if(obj.addEventLinstener){

​      obj.addEventLinstener(eventStr,callback , false);

​     }else{

​      obj.attachEvent("on"+eventStr, function(){

​         在匿名函数中调用回调函数

​         callback.call(obj)

})}}; 

#### 事件的传播: 三个阶段

1,捕获阶段:从外向内,从目标元素的祖先元素开始,先目标元素进行事件的捕获,默认此时不会触发事件.

2,目标阶段:事件捕获到目标元素,捕获结束开始在目标元素触发事件

3,冒泡阶段:事件从目标元素向他的祖先元素传递 ,依次实现祖先元素上的事件.

若希望在捕获阶段就触发事件,可以将addEventLinstener()的第三个参数设置为true,但一般不会这样设置.

当我们拖拽一个网页中的内容时,浏览器会默认去搜索引擎中搜索内容,可以通过

return false;取消 ie8不可以.ie中调用一个元素的setCapture()方法后,这个元素将会把下一次所有的鼠标按下相关的事件捕获到自身上.可以在元素中设置以防止多选鼠标松开后,元素调用releaseCapture()方法释放捕获.

#### 滚轮事件:

onwheel 火狐中使用DOMMouseScroll来绑定

wheelDelta:获取滚轮滚动的方向 向上滚 120 向下滚 -120 火狐中为detail来获取滚动方向,向上为正值,向下为负值.

当有浏览器有滚轮时,在元素上滚动滚轮会使页面滚动,想要取消,要return false;

火狐中使用addEventLinstener()方法绑定下响应函数,取消默认行为时不能使用return false 需要使用event.preventDefault();取消

#### 键盘事件:

键盘事件一般都会绑定给能够获取焦点的对象或者是document

 onkeydown 按键被按下 按住不松手,事件会一直被触发,第一下和第二次间隔事件稍微长一些,其他的非常快.为了防止误操作

onkeyup 按键被松开 

keyCode:获取按下的健的编码,来判断哪个按键被按下.

altkey:

ctrlkey:

shiftkey:用来判断 alt ctrl shift 是否被按下

 

### BOM:浏览器对象模型

BOM可以是我们通过js来操作浏览器,在BOM中为我们提供了一组对象,用来完成对浏览器的操作.

#### BOM对象:

 Window: 代表的是整个浏览器的窗口,同时window也是网页中的全局对象

 Navigator:代表的当前浏览器的信息,通过该对象可以识别不同的浏览器

 Location: 代表当前浏览器的地址栏信息,通过Location可以获取地址栏信息,或者操作浏览器跳转页面.

 History: 代表浏览器的历史记录,可以通过该对象来操作浏览器的历史记录,不能获取到具体的历史记录,只能操作浏览器向前或者先后翻页.

 Screen : 代表用户的屏幕的信息,通过该独显可以通过用户的显示器的相关信息.

这些BOM对象在浏览器中都是作为window对象的属性保存的,

​        可以通过window对象来使用,也可以直接使用

 

#### Navigator:

使用navigator.userAgent来判断浏览器的信息

   userAgent是一个字符串,包含用来面熟浏览器信息的内容,不同浏览器有不同的userAgent

如果不能通过userAgent判断,还可以通过一些浏览器中特有的对象,来判断浏览器的信息.如ie中的ActiveXObject.  "ActiveXObject" in window判断

 

#### History:对象可以用来操作向前或者向后翻页

length:获取到当次访问的链接数量.

back():返回到上一个页面

forward();去到下一个页面

go();跳转到指定页面,需要一个整数作为参数.正数代表向前跳转,负数代表向后跳转

 

#### Location:该对象中封装了浏览器的地址栏信息

若直接打印location,则可以获取到地址栏的信息(当前页面的完整路径)

若直接将lacation属性修改为一个完整的路径,或者相对路径,则页面会自动跳转到该路径,并且会生成相应的历史记录.

assign():用来跳转到其他的页面,作用和直接修改location一样

reload():用来重新加载当前页面 作用等于f5.若在方法中传入true作为参数,则会强制清空缓存

repalce():可以使用新的页面来替换当前页面.调用完毕会跳转页面,不会生成历史记录,不能回退.

#### Window:

alert("..."):弹出一个警告框

confirm(""):显示一段消息以及确认按钮和取消按钮的对话框

prompt():显示可提示用户输入的对话框

#### 定时器:

setInterval():按照指定的周期(以毫秒计)来调用函数或者计算表达式.,会返回一个number类型数据.为该定时器的标识.

​      参数:1.回调函数,该函数每隔一段时间被调用一次

​          2,每次调用间隔的时间,单位是毫秒.

​      定时器会累计开启,关闭时只会关闭最后一个开启的定时器.在开启一个定时器时,需要关闭当前元素上的上一个定时器.

setTimeout():在指定的毫秒数后调用函数或者计算表达式.只执行一次

clearInterval():关闭定时器,需要一个定时器标识作为参数. 可以接收任意参数,如果参数是一个有效的标识,则会停止相应的定时器,若参数无效,什么都不会做

clearTimeout():取消由上面方法设置的timeout

##### 类的操作"

可以通过修改元素的class属性来间接的修改样式

这样只需要修改一次,即可同时修改多个样式,浏览器只需要重新渲染页面一次,性能比较好,使行为和表现进一步分离

  

#### JSON: JavaScript Object Notation JS对象表示法

JS中的对象只有JS自己认识,其他的语言都不认识.

 JSON就是一个特殊格式的字符串,这个字符串可以被任意的语言所识别,并且可以转换为任意语言的对象.JSON在开发中主要用于数据的交互

JSON和JS对象的格式一样,只不过JSON字符串中的属性名必须加双引号,其他的和JS语法一致.

##### JSON的分类:

 1,对象 {}

 2.数组 []

##### JSON中允许的值:

 1,字符串

 2,数值

 3,布尔型

 4,null

 5,对象

 6,数组

##### 将JSON字符串转换为js对象:

  在js中,为我们提供了一个工具类,就叫JSON.

JSON. parse():可以将一个JSON字符串转换为JS对象,需要一个JSON字符串作为参数,会将该字符串转换为js对象返回.

将js对象转化为JSON字符串:

JSON.stringify() : 将js对象转化为JSON字符串: 需要一个js对象作为参数,返回一个JSON字符串.

JSON在ie7及一下不兼容

eval()函数可以用来执行一段字符串形式的js代码,并将执行结果返回.,如果使用eval()执行的字符串中含有{},它会将{}当作是代码块,若不希望将其当成代码块解析,则需要在字符串前后各加一个().

尽量不要使用,首先他的执行性能比较差,然后它还具有安全隐患.

若要需要兼容ie7,需要引入一个js文件.