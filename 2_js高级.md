### typeof和instanceof 

typeof返回数据类型的字符串表达,返回字符串中都是小写

​    可以判断:undefined/数值/字符串/布尔值/function

​    不能判断:null 与oject object与array

instanceof 返回对象的具体类型.

### 1,undefined与null的区别

undefined代表了定义了未赋值

null代表了定义了,赋值为null

#### 2,什么时候赋值为null

1,初始赋值,表明对象要赋值为对象

2,结束前,让对象成为垃圾对象

3,严格区分变量类型和数据类型

#####  数据的类型:

  基本类型

  对象类型

#####  变量的类型:(变量内存值的类型)

  基本类型:保存的就是基本类型的数据

  引用类型:保存的地址值

 

#### 1什么是数据:

  存储在内存中代表特定信息的值

#### 2什么是内存:

 可以存储数据的空间(临时的)

  一小块内存的两个数据:

​    内部存储的数据

​    地址值 

#####  内存分类:

   栈内存:全局变量/局部变量

   对内存:对象.

#### 3什么是变量:

 可以变化的量,有病啊两名和变量值组成,每个变量都对应一块小的内存,变量名用来查找对应的内存,变量值.变量值就是内存中保存的数据.

4,内存,数据和变量三者之间的关系:

  内存是用来存储数据的空间

   变量是是内存的标识

####   赋值和内存的问题:

var a = xxx

xxx是基本数据,a内存中保存的是这个数据

xxx是对象,保存的是对象地址值

xxx是一个变量,保存的xxx的内存内容.

在js调用函数时传递变量参数时,是值传递

#### js引擎如何让管理内存:

##### 1内存生命周期

  分配内存空间,得到使用权.

  存储数据,可以对数据进行操作

  释放空间

##### 2,释放内存

 局部变量:函数执行完自动释放

 全局变量:

 对象:称为垃圾对象==>垃圾回收器回收

 

IIFE:立即调用函数表达式 :匿名函数自调用

作用:

隐藏实现,不会污染外部命名空间

 

1,$是一个函数

2,$执行后返回的是一个对象.

## 原型:

  1,每个函数都有一个prototype属性,它默认指向一个Oject空对象(即原型对象)

  原型对象中有一个属性constructor,他指向函数对象.

  2,给原型对象添加属性

  作用:函数的所有实例对象自动拥有原型中的属性(方法),原型对象添加的属性,实例对象可以访问

 

### 原型链:

访问一个对象的属性时,现在自身属性中查找,找到返回

如果没有,再沿着_proto_这条链向上查找,找到返回

如果最终没找到,返回undefined

别名:隐式原型链

作用:查找对象的属性

构造函数/原型/原型链的关系:

  函数的显式原型指向的对象默认是空Object实例对象(但是Object的原型除外,Object的原型是null)  

 Object的原型对象是原型链的尽头 Object.prototype.__proto__ == null; 

 所有函数都是Function的实例.(包括Function自身)

 所有函数的隐性原型指向Function.prototype,包括Funcioon

 

### 原型链的属性:

读取对象的属性值时,会自动到原型链中查找

设置对象的属性值时,不会查找原型链,如果对象中没有这个属性,直接添加此属性并设置其值.

方法一般定义在原型中,属性一般通过构造函数定义在对象本身上.

 

instanceof 如何判断的?

 A instanceof B

若B 的函数的显性原型对象在A对象的原型链上,返回true

 

## 闭包:

### \1. 如何产生闭包?

 \* 当一个嵌套的内部(子)函数引用了嵌套的外部(父)函数的变量(函数)时, 就产生了闭包

### \2. 闭包到底是什么?

 \* 使用chrome调试查看

 \* 理解一: 闭包是嵌套的内部函数(绝大部分人)

 \* 理解二: 包含被引用变量(函数)的对象(极少数人)

 \* 注意: 闭包存在于嵌套的内部函数中

### \3. 产生闭包的条件?

 \* 函数嵌套

 \* 内部函数引用了外部函数的数据(变量/函数)

执行函数定义就会产生闭包(不用调用内部函数)

 